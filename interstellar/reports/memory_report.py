import math

import reports.constants as c
import reports.writer as w


def build_table(pdf, table, header):
    cache = int(len(header) / 2)
    pdf.cell(50, c.height_margin, "Exploration Table:", "B", 0, align="L")
    pdf.ln(c.meduim_new_line)
    pdf.set_font('Arial', 'B', c.h3 - cache)
    margin = 196 / (2 * cache + 1)
    for head in header:
        pdf.cell(margin, c.height_margin, head, 0, 0, align="C")
    pdf.ln(c.small_new_line)
    pdf.set_font('Arial', '', c.h3 - cache)
    # get min
    min_cost = math.inf
    for i in range(len(table)):
        for j in range(int(len(table[i]))):
            if min_cost > table[i][len(table[j]) - 1]:
                min_cost = float(table[i][len(table[j]) - 1])

    for i in range(len(table)):
        for j in range(int(len(table[i]) / 2)):
            if min_cost == float(table[i][len(table[i]) - 1]):
                pdf.set_font('Arial', 'B', c.h3 - cache)
            pdf.cell(margin, c.height_margin, str(float(table[i][j])), 0, 0, align="C")
            pdf.cell(margin, c.height_margin, str(float(table[i][j + cache])), 0, 0, align="C")
            pdf.set_font('Arial', '', c.h3 - cache)
        if min_cost == float(table[i][len(table[i]) - 1]):
            pdf.set_font('Arial', 'B', c.h3 - cache)
        pdf.cell(margin, c.height_margin, str(float(table[i][len(table[i]) - 1])), 0, 0, align="C")
        pdf.set_font('Arial', '', c.h3 - cache)
        pdf.ln(c.small_new_line)
    pdf.ln(c.large_new_line)


def generate(exploration_tb, content, note, arch_info, network_info):
    pdf = w.PDF()
    pdf.alias_nb_pages()
    pdf.add_page()
    pdf.set_font('Arial', 'B', c.h1)
    # header of report
    """ Side Note: Name of Model """
    pdf.cell(0, 10, "Analyzer Report {Memory Capcity}", 1, 0, 'C')
    pdf.ln(c.inter_mid_new_line)
    mem_levels = arch_info['mem_levels']

    """ Introduction """
    body = "This report generated by Convolutional Neural Network Inference Analyzer " + \
           "(CNN-IA) to summarize the analysis needed to reach the optimal memory capacity " + \
           "for " + network_info['layer_name'] +\
           " by varying architecture parameters for the optimal loop blocking in a restricted schedule space."

    w.introduction(body, pdf)

    """
        Memory Architecture
    """
    w.to_mem_arch(arch_info, pdf)

    """ Glossary"""

    """  
        explanation of memory caches and loops notations
    """

    w.glossary(mem_levels, pdf)
    pdf.ln(c.meduim_new_line)

    """
        Output 
    """
    pdf.add_page()
    pdf.set_font('Arial', 'B', c.h1)

    # Exploration parameters
    exploration_param = {'Scaling count': arch_info['explore_points'],
                         'Size scaling': arch_info['capacity_scale'],
                         'Cost scaling': arch_info['access_cost_scale']}

    pdf.cell(65, c.height_margin, "Exploration Parameters:", "B", 0, align="L")
    pdf.ln(c.meduim_new_line)
    w.make_table(list(exploration_param.keys()), list(exploration_param.values()), pdf)
    pdf.ln(c.inter_small_new_line)

    # Exploration Table
    pdf.set_font('Arial', 'B', c.h1)
    head = []
    for index in range(0, mem_levels):
        head.append("L" + str(index) + "-SIZE")
        head.append("L" + str(index) + "-COST")
    head.append("TOTAL")
    build_table(pdf, exploration_tb, head)

    pdf.output('reports/memory_output.pdf', 'F')
